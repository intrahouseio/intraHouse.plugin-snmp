const EventEmitter = require('events');
const dgram = require ('dgram');

const STORE = {
  conections: {},
  hosts: {},
}

class FakeSocker extends EventEmitter {
  constructor(host, port) {
    super();
    this.host = host;
    this.port = port;
  }
  unref() {

  }

  send(buffer, n, l, port, target, callback) {
    if (STORE.conections[this.port]) {
      STORE.conections[this.port].send(buffer, n, l, this.port, this.host, callback);
    }
  }

  bind() {
    if (STORE.hosts[this.host]) {
      STORE.hosts[this.host].push(this);
    } else {
      STORE.hosts[this.host] = [];
      STORE.hosts[this.host].push(this);
    }
  }

  ref() {

  }
}

function message(msg, rinfo) {
  if (STORE.hosts[rinfo.address]) {
    STORE.hosts[rinfo.address]
      .forEach(socket => socket.emit('message', msg, rinfo));
  }
}

function error(e, host) {
  if (STORE.hosts[host]) {
    STORE.hosts[host]
      .forEach(socket => socket.emit('error', e));
  }
}

function close(e, host) {
  if (STORE.hosts[host]) {
    STORE.hosts[host]
      .forEach(socket => socket.emit('close', e));
  }
}

function createSocket(host, port, protocol) {
  if (!STORE.conections[port]) {
    const socket = dgram.createSocket({ type:protocol, reuseAddr:true });

    socket.on ('message', message);
    socket.on ('close', e => close(e, host));
    socket.on ('error', e => error(e, host));

    socket.bind(port)

    STORE.conections[port] = socket;
  }
  return new FakeSocker(host, port);
}

module.exports = { createSocket };
